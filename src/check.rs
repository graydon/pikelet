//! Contexts and type checking

use core::{CTerm, ITerm, RcCTerm, RcITerm, RcType, Value};
use var::{Debruijn, Name, Named, Scope, Var};

#[derive(Debug, Clone, PartialEq)]
pub enum TypeError {
    IllegalApplication,
    ExpectedFunction {
        lam_expr: RcCTerm,
        expected: RcType,
    },
    Mismatch {
        expr: RcITerm,
        found: RcType,
        expected: RcType,
    },
    UnboundVariable(Name),
}

/// Contexts
pub enum Context<'a> {
    // Γ ::= ε           1. empty context
    //     | Γ,x:τ       2. context extension
    Empty,                         // 1.
    Cons(&'a Context<'a>, RcType), // 2.
}

impl Default for Context<'static> {
    fn default() -> Context<'static> {
        Context::Empty
    }
}

impl<'a> Context<'a> {
    pub fn extend(&'a self, ty: RcType) -> Context<'a> {
        Context::Cons(self, ty)
    }

    pub fn lookup_ty(&'a self, x: Debruijn) -> Option<&'a RcType> {
        match (self, x) {
            (&Context::Empty, _) => None,
            (&Context::Cons(parent, ref value), x) => match x.pred() {
                None => Some(value),
                Some(x) => parent.lookup_ty(x),
            },
        }
    }

    /// Check that the type of an expression is compatible with the expected type
    pub fn check(&self, expr: &RcCTerm, expected_ty: &RcType) -> Result<(), TypeError> {
        // Γ ⊢ e :↓ τ
        match *expr.inner {
            //  1.  Γ ⊢ e :↑ τ
            // ─────────────────── (CHECK/INFER)
            //      Γ ⊢ e :↓ τ
            CTerm::Inf(ref inferrable_expr) => {
                let inferred_ty = self.infer(inferrable_expr)?; // 1.
                match &inferred_ty == expected_ty {
                    true => Ok(()),
                    false => Err(TypeError::Mismatch {
                        expr: inferrable_expr.clone(),
                        found: inferred_ty,
                        expected: expected_ty.clone(),
                    }),
                }
            }

            //  1.  Γ, x:τ₁ ⊢ e :↓ τ₂
            // ─────────────────────────────── (CHECK/LAM)
            //      Γ ⊢ λx→e :↓ (x:τ₁)→τ₂
            CTerm::Lam(ref lam_scope) => match *expected_ty.inner {
                Value::Pi(ref pi_scope) => {
                    self.extend(pi_scope.unsafe_param.1.clone())
                        .check(&lam_scope.unsafe_body, &pi_scope.unsafe_body) // 1.
                }
                _ => Err(TypeError::ExpectedFunction {
                    lam_expr: expr.clone(),
                    expected: expected_ty.clone(),
                }),
            },
        }
    }

    pub fn infer(&self, expr: &RcITerm) -> Result<RcType, TypeError> {
        // Γ ⊢ e :↑ τ
        match *expr.inner {
            //  1.  Γ ⊢ ρ₁ :↓ Type
            //  2.  ρ ⇓ τ
            //  3.  Γ ⊢ e :↓ τ
            // ───────────────────────── (INFER/ANN)
            //      Γ ⊢ (e : ρ) :↑ τ
            ITerm::Ann(ref expr, ref ty) => {
                self.check(ty, &Value::Type.into())?; // 1.
                let simp_ty = ty.eval(); // 2.
                self.check(expr, &simp_ty)?; // 3.
                Ok(simp_ty)
            }

            // ─────────────────── (INFER/TYPE)
            //  Γ ⊢ TYPE :↑ Type
            ITerm::Type => Ok(Value::Type.into()),

            //  1.  Γ ⊢ ρ :↓ Type
            //  2.  ρ ⇓ τ₁
            //  3.  Γ, x:τ₁ ⊢ e :↑ τ₂
            // ─────────────────────────────── (INFER/LAM)
            //      Γ ⊢ λx:ρ→e :↑ (x:τ₁)→τ₂
            ITerm::Lam(ref scope) => {
                self.check(&scope.unsafe_param.1, &Value::Type.into())?; // 1.
                let simp_param_ty = scope.unsafe_param.1.eval(); // 2.
                let body_ty = self.extend(simp_param_ty.clone())
                    .infer(&scope.unsafe_body)?; // 3.

                Ok(
                    Value::Pi(Scope {
                        unsafe_param: Named(scope.unsafe_param.0.clone(), simp_param_ty),
                        unsafe_body: body_ty, // shift??
                    }).into(),
                )
            }

            //  1.  Γ ⊢ ρ₁ :↓ Type
            //  2.  ρ₁ ⇓ τ₁
            //  3.  Γ, x:τ₁ ⊢ ρ₂ :↓ Type
            // ────────────────────────────── (INFER/PI)
            //      Γ ⊢ (x:ρ₁)→ρ₂ :↑ Type
            ITerm::Pi(ref scope) => {
                self.check(&scope.unsafe_param.1, &Value::Type.into())?; // 1.
                let simp_param_ty = scope.unsafe_param.1.eval(); // 2.
                self.extend(simp_param_ty)
                    .check(&scope.unsafe_body, &Value::Type.into())?; // 3.
                Ok(Value::Type.into())
            }

            //  1.  Γ(x) = τ
            // ────────────────────────────── (INFER/VAR)
            //      Γ ⊢ x :↑ τ
            ITerm::Var(ref var) => match *var {
                Var::Free(ref name) => Err(TypeError::UnboundVariable(name.clone())),
                Var::Bound(Named(_, b)) => match self.lookup_ty(b) {
                    Some(ty) => Ok(ty.clone()), // 1.
                    None => panic!("ICE: index out of bounds"),
                },
            },

            //  1.  Γ ⊢ e₁ :↑ (x:τ₁)→τ₂
            //  2.  Γ ⊢ e₂ :↓ τ₁
            //  3.  τ₂[x↦e₂] ⇓ τ₃
            // ────────────────────────────── (INFER/APP)
            //      Γ ⊢ e₁ e₂ :↑ τ₃
            ITerm::App(ref fn_expr, ref arg_expr) => {
                let fn_type = self.infer(fn_expr)?; // 1.
                match *fn_type.inner {
                    Value::Pi(ref scope) => {
                        self.check(arg_expr, &scope.unsafe_param.1)?; // 2.
                        let body_ty = scope.unsafe_body.open0(&arg_expr.eval()); // 3.
                        Ok(body_ty)
                    }
                    // TODO: More error info
                    _ => Err(TypeError::IllegalApplication),
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use core::RcValue;

    use super::*;

    fn parse(src: &str) -> RcITerm {
        RcITerm::from_parse(&src.parse().unwrap()).unwrap()
    }

    #[test]
    fn extend_lookup_ty() {
        let x: RcValue = Value::Var(Var::Free(Name::user("x"))).into();
        let y: RcValue = Value::Var(Var::Free(Name::user("y"))).into();

        let context0 = Context::Empty;

        assert_eq!(context0.lookup_ty(Debruijn(0)), None);

        let context1 = context0.extend(x.clone());

        assert_eq!(context1.lookup_ty(Debruijn(0)), Some(&x));
        assert_eq!(context1.lookup_ty(Debruijn(1)), None);

        let context2 = context1.extend(y.clone());

        assert_eq!(context2.lookup_ty(Debruijn(0)), Some(&y));
        assert_eq!(context2.lookup_ty(Debruijn(1)), Some(&x));
        assert_eq!(context2.lookup_ty(Debruijn(2)), None);
    }

    mod infer {
        use super::*;

        #[test]
        fn free() {
            let ctx = Context::default();

            let given_expr = r"x";
            let x = Name::user("x");

            assert_eq!(
                ctx.infer(&parse(given_expr)),
                Err(TypeError::UnboundVariable(x)),
            );
        }

        #[test]
        fn ty() {
            let ctx = Context::default();

            let given_expr = r"Type";
            let expected_ty = r"Type";

            assert_eq!(
                ctx.infer(&parse(given_expr)).unwrap(),
                parse(expected_ty).eval(),
            );
        }

        #[test]
        fn ann_ty_id() {
            let ctx = Context::default();

            let given_expr = r"(\a => a) : Type -> Type";
            let expected_ty = r"Type -> Type";

            assert_eq!(
                ctx.infer(&parse(given_expr)).unwrap(),
                parse(expected_ty).eval(),
            );
        }

        #[test]
        fn ann_arrow_ty_id() {
            let ctx = Context::default();

            let given_expr = r"(\a => a) : (Type -> Type) -> (Type -> Type)";
            let expected_ty = r"(Type -> Type) -> (Type -> Type)";

            assert_eq!(
                ctx.infer(&parse(given_expr)).unwrap(),
                parse(expected_ty).eval(),
            );
        }

        #[test]
        fn ann_id_as_ty() {
            let ctx = Context::default();

            let given_expr = r"(\a => a) : Type";

            match ctx.infer(&parse(given_expr)) {
                Err(TypeError::ExpectedFunction { .. }) => {}
                other => panic!("unexpected result: {:#?}", other),
            }
        }

        #[test]
        fn app() {
            let ctx = Context::default();

            let given_expr = r"(\a : Type => a) Type";
            let expected_ty = r"Type";

            assert_eq!(
                ctx.infer(&parse(given_expr)).unwrap(),
                parse(expected_ty).eval(),
            );
        }

        #[test]
        fn app_ty() {
            let ctx = Context::default();

            let given_expr = r"Type Type";

            assert_eq!(
                ctx.infer(&parse(given_expr)),
                Err(TypeError::IllegalApplication),
            )
        }

        #[test]
        fn lam() {
            let ctx = Context::default();

            let given_expr = r"\a : Type => a";
            let expected_ty = r"(a : Type) -> Type";

            assert_eq!(
                ctx.infer(&parse(given_expr)).unwrap(),
                parse(expected_ty).eval(),
            );
        }

        #[test]
        fn pi() {
            let ctx = Context::default();

            let given_expr = r"(a : Type) -> a";
            let expected_ty = r"Type";

            assert_eq!(
                ctx.infer(&parse(given_expr)).unwrap(),
                parse(expected_ty).eval(),
            );
        }

        #[test]
        fn id() {
            let ctx = Context::default();

            let given_expr = r"\a : Type => \x : a => x";
            let expected_ty = r"(a : Type) -> a -> a";

            assert_eq!(
                ctx.infer(&parse(given_expr)).unwrap(),
                parse(expected_ty).eval(),
            );
        }

        #[test]
        fn id_ann() {
            let ctx = Context::default();

            let given_expr = r"(\a => \x : a => x) : (A : Type) -> A -> A";
            let expected_ty = r"(a : Type) -> a -> a";

            assert_eq!(
                ctx.infer(&parse(given_expr)).unwrap(),
                parse(expected_ty).eval(),
            );
        }

        #[test]
        fn id_app_ty_arr_ty() {
            let ctx = Context::default();

            let given_expr = r"(\a : Type => \x : a => x) Type (Type -> Type)";
            let expected_ty = r"Type -> Type";

            assert_eq!(
                ctx.infer(&parse(given_expr)).unwrap(),
                parse(expected_ty).eval(),
            );
        }

        #[test]
        fn id_app_arr_pi_ty() {
            let ctx = Context::default();

            let given_expr = r"(\a : Type => \x : a => x) (Type -> Type) (\x : Type => Type)";
            let expected_ty = r"\x : Type => Type";

            assert_eq!(
                ctx.infer(&parse(given_expr)).unwrap(),
                parse(expected_ty).eval(),
            );
        }

        #[test]
        fn apply() {
            let ctx = Context::default();

            let given_expr = r"
                \a : Type => \b : Type =>
                    \f : (a -> b) => \x : a => f x
            ";
            let expected_ty = r"
                (a : Type) -> (b : Type) ->
                    (a -> b) -> a -> b
            ";

            assert_eq!(
                ctx.infer(&parse(given_expr)).unwrap(),
                parse(expected_ty).eval(),
            );
        }

        #[test]
        fn const_() {
            let ctx = Context::default();

            let given_expr = r"\a : Type => \b : Type => \x : a => \y : b => x";
            let expected_ty = r"(a : Type) -> (b : Type) -> a -> b -> a";

            assert_eq!(
                ctx.infer(&parse(given_expr)).unwrap(),
                parse(expected_ty).eval(),
            );
        }

        #[test]
        fn compose() {
            let ctx = Context::default();

            let given_expr = r"
                \a : Type => \b : Type => \c : Type =>
                    \f : (b -> c) => \g : (a -> b) => \x : a =>
                        f (g x)
            ";
            let expected_ty = r"
                (a : Type) -> (b : Type) -> (c : Type) ->
                    (b -> c) -> (a -> b) -> (a -> c)
            ";

            assert_eq!(
                ctx.infer(&parse(given_expr)).unwrap(),
                parse(expected_ty).eval(),
            );
        }

        mod church_encodings {
            use super::*;

            #[test]
            fn and() {
                let ctx = Context::default();

                let given_expr = r"\p : Type => \q : Type => (c : Type) -> (p -> q -> c) -> c";
                let expected_ty = r"Type -> Type -> Type";

                assert_eq!(
                    ctx.infer(&parse(given_expr)).unwrap(),
                    parse(expected_ty).eval(),
                );
            }

            #[test]
            fn and_intro() {
                let ctx = Context::default();

                let given_expr = r"
                    \p : Type => \q : Type => \x : p => \y : q =>
                        \c : Type => \f : (p -> q -> c) => f x y
                ";
                let expected_ty = r"
                    (p : Type) -> (q : Type) -> p -> q ->
                        ((c : Type) -> (p -> q -> c) -> c)
                ";

                assert_eq!(
                    ctx.infer(&parse(given_expr)).unwrap(),
                    parse(expected_ty).eval(),
                );
            }

            #[test]
            fn and_proj_left() {
                let ctx = Context::default();

                let given_expr = r"
                    \p : Type => \q : Type => \pq : (c : Type) -> (p -> q -> c) -> c =>
                        pq p (\x => \y => x)
                ";
                let expected_ty = r"
                    (p : Type) -> (q : Type) ->
                        ((c : Type) -> (p -> q -> c) -> c) -> p
                ";

                assert_eq!(
                    ctx.infer(&parse(given_expr)).unwrap(),
                    parse(expected_ty).eval(),
                );
            }

            #[test]
            fn and_proj_right() {
                let ctx = Context::default();

                let given_expr = r"
                    \p : Type => \q : Type => \pq : (c : Type) -> (p -> q -> c) -> c =>
                        pq q (\x => \y => y)
                ";
                let expected_ty = r"
                    (p : Type) -> (q : Type) ->
                        ((c : Type) -> (p -> q -> c) -> c) -> q
                ";

                assert_eq!(
                    ctx.infer(&parse(given_expr)).unwrap(),
                    parse(expected_ty).eval(),
                );
            }
        }
    }
}
